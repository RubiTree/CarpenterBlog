<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CarpenterBlog]]></title>
  <link href="http://blog.zhengyu.site/atom.xml" rel="self"/>
  <link href="http://blog.zhengyu.site/"/>
  <updated>2018-12-21T11:09:55+08:00</updated>
  <id>http://blog.zhengyu.site/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[test2]]></title>
    <link href="http://blog.zhengyu.site/15453616733476.html"/>
    <updated>2018-12-21T11:07:53+08:00</updated>
    <id>http://blog.zhengyu.site/15453616733476.html</id>
    <content type="html"><![CDATA[
<p>jiejfie</p>

<p>feifjeif</p>

<p>fejfeifjei</p>

<ol>
<li>然后就有一种办法，能通过线性变换来表示仿射变换，这样对于包括平移的四种基本操作，都能像线性变换一样，消除中间坐标的运算，这种办法简单说是：增加一个维度

<ol>
<li>先简要描述这个转化过程，非常简洁巧妙

<ol>
<li>\(\overrightarrow{P} = M · \overrightarrow{P_0} + \overrightarrow{T}\) 可以写成 \( \begin{bmatrix} \overrightarrow{P} \\ 1 \end{bmatrix} = \begin{bmatrix} M &amp; \overrightarrow{T} \\ 0 &amp; 1 \end{bmatrix} · \begin{bmatrix} \overrightarrow{P_0} \\ 1 \end{bmatrix} \) 

<ol>
<li>它们在数学上是等价的</li>
<li>（这里为了清晰，<code>2*1</code>的矩阵写成了向量的形式）</li>
</ol></li>
<li>而左侧就是仿射变换的形式，右侧则得到了线性变换的形式，完成了一个巧妙的转化

<ol>
<li>这里同时把二维坐标位置扩展成三维列向量，把二维变换矩阵扩展成三维矩阵</li>
<li>其中二维坐标位置扩展成的三维列向量在计算机图形学中被称为齐次坐标，新加入的维度信息被称为齐次参数，它只需要是一个非零值，最方便的做法是把它设置为1

<ol>
<li>（@@@拓展内容，可以再补充一点，是搜索的网页里有）为什么叫齐次，齐次在很多地方都有这个概念，它的英文单词是xx，表示同等的概念，在这里它就表示，</li>
</ol></li>
<li>我们只需要关注初始的 \(\overrightarrow{P_0}\) 和变换后的 \(\overrightarrow{P}\)，忽略第三个维度中1的信息，它的存在只是类似辅助线的效果，</li>
</ol></li>
</ol></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[eifjei]]></title>
    <link href="http://blog.zhengyu.site/15453337323289.html"/>
    <updated>2018-12-21T03:22:12+08:00</updated>
    <id>http://blog.zhengyu.site/15453337323289.html</id>
    <content type="html"><![CDATA[
<p>13</p>

<ol>
<li>canvas的操作是使用相对坐标系</li>
<li><p>如何通过相对坐标系的API来实现绝对坐标系的效果？</p>

<ol>
<li>那就是当成绝对坐标系的API来用，但是操作的顺序反过来写，只要基于一个单位阵变换，那么结果就跟调用绝对坐标系的API的效果是一样的，相当于手动前乘</li>
</ol></li>
<li><p><code>Canvas</code>变换是我们日常开发自定义控件用得比较多的东西，我们知道<code>Canvas</code>有这些变换操作：平移、缩放、旋转、错切，对<code>Canvas</code>进行变换后，再在<code>Canvas</code>上进行绘制，绘制出的图形就能体现出刚才变换的效果</p>

<ol>
<li>比如往 \(X\) 轴和 \(Y\) 轴的正方向平移100像素：</li>
<li>\(canvas.translate(100f, 100f) \\  canvas.drawBitmap(image)\)</li>
<li>（下图中每一个小方格间距50像素，每两个小方格间有一个刻度，代表100像素）</li>
<li><img src="media/15444051477462/15449657481603.gif" alt=""/></li>
</ol></li>
<li><p>但在我们要实现一些稍微复杂的连续变换时，比如不使用带偏移中心的API，把图形绕<code>(200, 200)</code>顺时针旋转90度；或是使用<code>Camera</code>进行连续变换以实现绕图片的中线翻转；或者其他更复杂的需求时，你会发现按照正常思路，往往无法得到你想要的效果</p></li>
<li><p>于是你可能会被告知：当成代码是倒着执行的，你先正着写，再把操作顺序倒过来，就能实现你的需求了。但是这样为什么能实现需求？为什么代码是倒着执行的？正着倒着是相对什么来的，为什么正着我也能写出好几种变换顺序？为什么有的时候这个方法不顶用？这些问题你可能都不清楚</p></li>
<li><p>然后你可能也听说过，对<code>Canvas</code>进行变换还可以通过操作<code>matrix</code>实现，但是具体怎么做，它的<code>pre</code>和<code>post</code>操作到底代表了什么意思，你可能不是很明白</p></li>
<li><p>最后你可能还知道可以通过<code>Camera</code>进行三维变换，但是变换的效果往往出乎你的预料</p></li>
<li><p>所以本文的目标就是要把这些问题分析清楚，让你真正理解<code>Canvas</code>变换究竟是怎么运作的，以及为什么这么运作 &lt;!--。如果你确定对于这些问题你都理解得非常清楚，那看到这就该干嘛干嘛去吧~--&gt;</p></li>
</ol>

<p>其他问题</p>

<ol>
<li>发现再复杂的效果（比如在(200,200)处，旋转45度，缩小3倍），都可以通过使用canvas的API，使用相对坐标系法，轻松地做到

<ol>
<li>一个通用套路就是：先移动，后进行原地旋转或缩放操作，就OK了</li>
<li>但是如果修改旋转或缩放中心，就不知道是不是也是这样（@@@？）</li>
<li>为什么选择或缩放操作的顺序可以交换，好像绝对相对都是这样，是不是可以从公式得到？（中间不能插入移动）（@@@？）</li>
</ol></li>
<li>除非是有需要两轮或多轮操作的场景，第二轮的所有操作都要考虑第一轮的结果，这时候就会比较难算了

<ol>
<li>但主要难算的第一下的移动，旋转和缩放都比较好算</li>
<li>而且发现其实没有多轮操作的场景，你完全可以通过两次从原点的操作实现效果</li>
<li>但你可以强行有，比如我就是要演示一个动画，从效果1到效果2，那就最好做相对操作了</li>
</ol></li>
<li>一个非常疑惑的问题：扔物线说，你可以按照相反的顺序写

<ol>
<li>其实不管是相对操作还是绝对操作，你都可以用不同的顺序操作（不同的顺序，也会让操作的参数不同），得到同样的效果，所以扔物线说，你可以按照相反的顺序写，什么叫相反的顺序，什么又是正的顺序呢？</li>
<li>答案是，只要你按照绝对坐标系的思路写，不管什么操作顺序，只要倒过来写，就都会是对的效果，正着写，都不对</li>
</ol></li>
<li>最后的问题，为什么绝对坐标系没有中心的说法，但你把相对坐标系有中心的API当成绝对的写，有中心，为什么也是生效的，什么是中心，它是怎么实现的，相对绝对里的中心有什么区别？

<ol>
<li>想一下，绝对坐标系的绕中心操作要怎么实现

<ol>
<li>比如绕中心旋转，postMove(-rotateX,-rotateY) -&gt; postRotate() -&gt; postMove(rotateX,rotateY)，极其简单（cur是旋转点在绝对坐标系上的坐标）</li>
<li>也可以给出旋转点在相对坐标系上的坐标，你就得算出在绝对坐标系上是多少</li>
</ol></li>
<li>想一下，相对坐标系的绕中心操作要怎么实现

<ol>
<li>比如绕中心旋转，其实相对坐标系也是矩阵操作，如果。。。</li>
<li>其实用相对坐标系的本质是，用pre操作实现同样的效果</li>
<li>所以有一个A，你要用后乘实现MRM-1*A的效果，好像没法做很简单地做，除非A是单位阵，但好像系统API实现了啊</li>
<li>得看一下相对操作提供的元操作是什么（@@@？需要看吗？不就跟绝对是一样的吗？）</li>
<li>一般这时给出的旋转点是相对坐标系上的坐标</li>
<li>比如我就是要绕相对的0点转，那直接转就行，如果要绕相对的（100，100）转，我曹，完全不会操作</li>
<li>其实绕某点旋转，旋转的效果是体现在绝对坐标系上的，相对坐标系其实相对自己，感受不到任何变换。所以其实前乘和后乘的区别，不是参考绝对坐标系还是参考相对坐标系，都是参考绝对坐标系，区别是变换是后面的变换参考前面的变换被改变，还是后面的变化直接改变前面的变换</li>
<li>所以，就是把相对坐标系的原点移动到旋转点，开始旋转，然后移动回去，这个移动回去完全可以被前面操作影响</li>
<li>所以操作是：preMove(rotateX,rotateY) -&gt; preRotate() -&gt; preMove(-rotateX,-rotateY)（跟上面的rotate值不一样）</li>
<li>诶，这真的可以吗，为什么我前面觉得毫无办法</li>
<li>这里的一个关键动作是：「把相对坐标系的原点移动到旋转点」，这步是灵机一动，但为什么有效，需要证明一下，或者用公式推导一下。用纸法设想一下，发现能理解，但确实需要一些几何的理解，不太直观</li>
</ol></li>
<li>有两页公式推导（@@@？！这里要集中写），很清晰</li>
<li>（@@@？这里还有一开始在探索相对的两种写法留下的问题，当时的想法太简单，没有证明出来，现在可以看一下）</li>
</ol></li>
<li>其实整个操作都是在绝对坐标系中变换一个相对坐标系，操作的是一个坐标</li>
</ol>

]]></content>
  </entry>
  
</feed>
